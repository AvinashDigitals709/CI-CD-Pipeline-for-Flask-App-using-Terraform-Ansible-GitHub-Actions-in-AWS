name: CI-CD

on:
  push:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  BUCKET_NAME: terraform-state-avinash-backend   # <<-- change to your actual bucket name
  TF_DIR: terraform
  ANSIBLE_USER: ubuntu                            # override by adding secret ANSIBLE_USER if needed

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      # ---------------------------
      # Configure AWS credentials
      # ---------------------------
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # ---------------------------
      # Ensure S3 backend bucket exists (us-east-1 safe)
      # ---------------------------
      - name: Ensure S3 backend bucket exists
        run: |
          set -e
          echo "Checking S3 bucket: ${BUCKET_NAME} in region ${AWS_REGION}"
          if aws s3api head-bucket --bucket "${BUCKET_NAME}" 2>/dev/null; then
            echo "S3 bucket ${BUCKET_NAME} already exists"
          else
            echo "Creating S3 bucket ${BUCKET_NAME} in ${AWS_REGION}..."
            if [ "${AWS_REGION}" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "${BUCKET_NAME}"
            else
              aws s3api create-bucket \
                --bucket "${BUCKET_NAME}" \
                --region "${AWS_REGION}" \
                --create-bucket-configuration LocationConstraint="${AWS_REGION}"
            fi
            aws s3api put-bucket-versioning --bucket "${BUCKET_NAME}" --versioning-configuration Status=Enabled
            echo "Created bucket and enabled versioning."
          fi

      # ---------------------------
      # Install Terraform
      # ---------------------------
      - name: Install Terraform
        uses: hashicorp/setup-terraform@v2

      # ---------------------------
      # Terraform init/plan/apply
      # ---------------------------
      - name: Terraform Init
        working-directory: ${{ env.TF_DIR }}
        run: terraform init -input=false

      - name: Terraform Validate & Plan
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform validate || true
          terraform plan -out=tfplan -input=false

      - name: Terraform Apply
        working-directory: ${{ env.TF_DIR }}
        run: terraform apply -input=false -auto-approve tfplan

      # ---------------------------
      # Get EC2 Public IP (clean)
      # ---------------------------
      - name: Get EC2 Public IP
        id: get-ec2-ip
        working-directory: ${{ env.TF_DIR }}
        run: |
          set -e
          echo "Extracting EC2 public IP from Terraform output..."
          # try -raw first then fallback
          IP=$(terraform output -raw ec2_public_ip 2>/dev/null | tr -d '[:space:]' || true)
          if [ -z "$IP" ]; then
            # fallback to plain output and regex extract
            IP=$(terraform output ec2_public_ip 2>/dev/null | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -1 || true)
          fi
          if [ -z "$IP" ]; then
            echo "ERROR: Could not extract EC2 public IP"
            terraform output
            exit 1
          fi
          echo "EC2 Public IP extracted: $IP"
          echo "EC2_IP=$IP" >> $GITHUB_ENV
          echo "ip=$IP" >> $GITHUB_OUTPUT

      # ---------------------------
      # Write SSH private key
      # ---------------------------
      - name: Write SSH private key
        run: |
          set -e
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          echo "Wrote SSH private key to ~/.ssh/id_rsa"

      # ---------------------------
      # Disable strict host key checking (CI runner)
      # ---------------------------
      - name: Disable SSH host key checking
        run: |
          mkdir -p ~/.ssh
          touch ~/.ssh/config
          chmod 700 ~/.ssh
          cat <<'EOF' > ~/.ssh/config
Host *
  StrictHostKeyChecking no
  UserKnownHostsFile=/dev/null
EOF
          chmod 600 ~/.ssh/config
          echo "SSH host key checking disabled for CI runner"

      # ---------------------------
      # Wait until SSH port is available on the host
      # ---------------------------
      - name: Wait for EC2 SSH to be ready
        run: |
          set -e
          IP=${{ env.EC2_IP }}
          echo "Waiting for SSH on $IP:22"
          MAX=30
          SLEEP=10
          for i in $(seq 1 $MAX); do
            if nc -z -w 5 "$IP" 22; then
              echo "SSH is available on $IP"
              exit 0
            fi
            echo "Attempt $i/$MAX: SSH not ready yet; sleeping $SLEEP seconds..."
            sleep $SLEEP
          done
          echo "ERROR: SSH did not come up on $IP after $((MAX*SLEEP)) seconds."
          exit 1

      # ---------------------------
      # Create dynamic Ansible inventory
      # ---------------------------
      - name: Create dynamic Ansible inventory
        run: |
          set -e
          IP=${{ env.EC2_IP }}
          echo "[flask]" > inventory.ini
          echo "${IP} ansible_user=${{ env.ANSIBLE_USER }} ansible_ssh_private_key_file=~/.ssh/id_rsa" >> inventory.ini
          echo "Inventory file:"
          cat inventory.ini

      # ---------------------------
      # Install Ansible on runner
      # ---------------------------
      - name: Install Ansible
        run: |
          sudo apt-get update -y
          sudo apt-get install -y software-properties-common
          sudo apt-add-repository --yes --update ppa:ansible/ansible
          sudo apt-get install -y ansible

      # ---------------------------
      # Run Ansible playbook
      # ---------------------------
      - name: Run Ansible Playbook
        run: |
          ansible-playbook -i inventory.ini ansible/deploy.yml --private-key ~/.ssh/id_rsa -u ${{ env.ANSIBLE_USER }} -vv

      # ---------------------------
      # Optional: show public IP and test health endpoint
      # ---------------------------
      - name: Test health endpoint
        run: |
          IP=${{ env.EC2_IP }}
          echo "Testing http://${IP}/health"
          timeout 10 bash -c "until curl -sSf http://${IP}/health >/dev/null; do echo 'waiting for /health'; sleep 5; done"
          echo "Health endpoint responded successfully"
